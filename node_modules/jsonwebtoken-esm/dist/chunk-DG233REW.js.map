{
  "version": 3,
  "sources": ["../node_modules/jsonwebtoken/verify.js", "../src/verify.js"],
  "sourcesContent": ["const JsonWebTokenError = require('./lib/JsonWebTokenError');\nconst NotBeforeError = require('./lib/NotBeforeError');\nconst TokenExpiredError = require('./lib/TokenExpiredError');\nconst decode = require('./decode');\nconst timespan = require('./lib/timespan');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst jws = require('jws');\nconst {KeyObject, createSecretKey, createPublicKey} = require(\"crypto\");\n\nconst PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];\nconst RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if ((typeof options === 'function') && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n\n  let done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n  }\n\n  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString){\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  const parts = jwtString.split('.');\n\n  if (parts.length !== 3){\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  let decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, { complete: true });\n  } catch(err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  const header = decodedToken.header;\n  let getSecret;\n\n  if(typeof secretOrPublicKey === 'function') {\n    if(!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  }\n  else {\n    getSecret = function(header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function(err, secretOrPublicKey) {\n    if(err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    const hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey){\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      return done(new JsonWebTokenError('please specify \"none\" in \"algorithms\" to verify unsigned tokens'));\n    }\n\n    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {\n      try {\n        secretOrPublicKey = createPublicKey(secretOrPublicKey);\n      } catch (_) {\n        try {\n          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);\n        } catch (_) {\n          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))\n        }\n      }\n    }\n\n    if (!options.algorithms) {\n      if (secretOrPublicKey.type === 'secret') {\n        options.algorithms = HS_ALGS;\n      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {\n        options.algorithms = RSA_KEY_ALGS\n      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {\n        options.algorithms = EC_KEY_ALGS\n      } else {\n        options.algorithms = PUB_KEY_ALGS\n      }\n    }\n\n    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))\n    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))\n    }\n\n    if (!options.allowInvalidAsymmetricKeyTypes) {\n      try {\n        validateAsymmetricKey(header.alg, secretOrPublicKey);\n      } catch (e) {\n        return done(e);\n      }\n    }\n\n    let valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    const payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n      const match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      const invalid_issuer =\n              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\n              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      const signature = decodedToken.signature;\n\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};\n", "export { default } from 'jsonwebtoken/verify'\n"],
  "mappings": "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",
  "names": ["require_verify", "__commonJSMin", "exports", "module", "init_process", "init_buffer", "JsonWebTokenError", "NotBeforeError", "TokenExpiredError", "decode", "timespan", "validateAsymmetricKey", "PS_SUPPORTED", "jws", "KeyObject", "createSecretKey", "createPublicKey", "PUB_KEY_ALGS", "EC_KEY_ALGS", "RSA_KEY_ALGS", "HS_ALGS", "jwtString", "secretOrPublicKey", "options", "callback", "done", "err", "data", "clockTimestamp", "parts", "decodedToken", "header", "getSecret", "secretCallback", "hasSignature", "_", "Buffer", "e", "valid", "payload", "audiences", "targetAudience", "audience", "maxAgeTimestamp", "signature", "init_process", "init_buffer", "import_verify"]
}
